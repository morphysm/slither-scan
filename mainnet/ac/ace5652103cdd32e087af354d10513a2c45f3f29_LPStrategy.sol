// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "./interfaces/IStrategy.sol";
import "./interfaces/IUniswapV2Pair.sol";
import "./interfaces/IBentoBoxMinimal.sol";
import "./libraries/UniswapV2Library.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

abstract contract BaseStrategy is IStrategy, Ownable {
    using SafeERC20 for IERC20;

    address public immutable strategyToken;
    address public bentoBox;
    address public immutable factory;
    address public immutable bridgeToken;

    bool public exited; /// @dev After bentobox 'exits' the strategy harvest, skim and withdraw functions can no loner be called
    uint256 public maxBentoBoxBalance; /// @dev Slippage protection when calling harvest
    mapping(address => bool) public strategyExecutors; /// @dev EOAs that can execute safeHarvest

    bytes32 internal immutable pairCodeHash;

    event LogConvert(address indexed server, address indexed token0, address indexed token1, uint256 amount0, uint256 amount1);
    event LogSetStrategyExecutor(address indexed executor, bool allowed);

    /** @param _strategyToken Address of the underlying token the strategy invests.
        @param _bentoBox BentoBox address.
        @param _factory SushiSwap factory.
        @param _bridgeToken An intermedieary token for swapping any rewards into the underlying token.
        @param _strategyExecutor an EOA that will execute the safeHarvest function.
        @param _pairCodeHash This hash is used to calculate the address of a uniswap-like pool
                                by providing only the addresses of the two ERC20 tokens.
        @dev factory and bridgeToken can be address(0) if we don't expect rewards we would need to swap
    */
    constructor(
        address _strategyToken,
        address _bentoBox,
        address _factory,
        address _bridgeToken,
        address _strategyExecutor,
        bytes32 _pairCodeHash
    ) {
        strategyToken = _strategyToken;
        bentoBox = _bentoBox;
        factory = _factory;
        bridgeToken = _bridgeToken;
        pairCodeHash = _pairCodeHash;

        if (_strategyExecutor != address(0)) {
            strategyExecutors[_strategyExecutor] = true;
            emit LogSetStrategyExecutor(_strategyExecutor, true);
        }
    }

    //** Strategy implementation: override the following functions: */

    /// @notice Invests the underlying asset.
    /// @param amount The amount of tokens to invest.
    /// @dev Assume the contract's balance is greater than the amount
    function _skim(uint256 amount) internal virtual;

    /// @notice Harvest any profits made and transfer them to address(this) or report a loss
    /// @param balance The amount of tokens that have been invested.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    /// @dev amountAdded can be left at 0 when reporting profits (gas savings).
    /// amountAdded should not reflect any rewards or tokens the strategy received.
    /// Calcualte the amount added based on what the current deposit is worth.
    /// (The Base Strategy harvest function accounts for rewards).
    function _harvest(uint256 balance) internal virtual returns (int256 amountAdded);

    /// @dev Withdraw the requested amount of the underlying tokens to address(this).
    /// @param amount The requested amount we want to withdraw.
    function _withdraw(uint256 amount) internal virtual;

    /// @notice Withdraw the maximum available amount of the invested assets to address(this).
    /// @dev This shouldn't revert (use try catch).
    function _exit() internal virtual;

    /// @notice Claim any rewards reward tokens and optionally sell them for the underlying token.
    /// @dev Doesn't need to be implemented if we don't expect any rewards.
    function _harvestRewards() internal virtual {}

    //** End strategy implementation */

    modifier isActive() {
        require(!exited, "BentoBox Strategy: exited");
        _;
    }

    modifier onlyBentoBox() {
        require(msg.sender == bentoBox, "BentoBox Strategy: only BentoBox");
        _;
    }

    modifier onlyExecutor() {
        require(strategyExecutors[msg.sender], "BentoBox Strategy: only Executors");
        _;
    }

    function setStrategyExecutor(address executor, bool value) public onlyOwner {
        strategyExecutors[executor] = value;
        emit LogSetStrategyExecutor(executor, value);
    }

    /// @inheritdoc IStrategy
    function skim(uint256 amount) external override {
        _skim(amount);
    }

    /// @notice Harvest profits while preventing a sandwich attack exploit.
    /// @param maxBalance The maximum balance of the underlying token that is allowed to be in BentoBox.
    /// @param rebalance Whether BentoBox should rebalance the strategy assets to acheive it's target allocation.
    /// @param maxChangeAmount When rebalancing - the maximum amount that will be deposited to or withdrawn from a strategy to BentoBox.
    /// @param harvestRewards If we want to claim any accrued reward tokens
    /// @dev maxBalance can be set to 0 to keep the previous value.
    /// @dev maxChangeAmount can be set to 0 to allow for full rebalancing.
    function safeHarvest(
        uint256 maxBalance,
        bool rebalance,
        uint256 maxChangeAmount,
        bool harvestRewards
    ) internal onlyExecutor {
        if (harvestRewards) {
            _harvestRewards();
        }

        if (maxBalance > 0) {
            maxBentoBoxBalance = maxBalance;
        }

        IBentoBoxMinimal(bentoBox).harvest(strategyToken, rebalance, maxChangeAmount);
    }

    /** @inheritdoc IStrategy
    @dev Only BentoBox can call harvest on this strategy.
    @dev Ensures that (1) the caller was this contract (called through the safeHarvest function)
        and (2) that we are not being frontrun by a large BentoBox deposit when harvesting profits. */
    function harvest(uint256 balance, address sender) external override isActive onlyBentoBox returns (int256) {
        /** @dev Don't revert if conditions aren't met in order to allow
            BentoBox to continiue execution as it might need to do a rebalance. */

        if (sender == address(this) && IBentoBoxMinimal(bentoBox).totals(strategyToken).elastic <= maxBentoBoxBalance && balance > 0) {
            int256 amount = _harvest(balance);

            /** @dev Since harvesting of rewards is accounted for seperately we might also have
            some underlying tokens in the contract that the _harvest call doesn't report. 
            E.g. reward tokens that have been sold into the underlying tokens which are now sitting in the contract.
            Meaning the amount returned by the internal _harvest function isn't necessary the final profit/loss amount */

            uint256 contractBalance = IERC20(strategyToken).balanceOf(address(this));

            if (amount >= 0) {
                // _harvest reported a profit

                if (contractBalance > 0) {
                    IERC20(strategyToken).safeTransfer(bentoBox, contractBalance);
                }

                return int256(contractBalance);
            } else if (contractBalance > 0) {
                // _harvest reported a loss but we have some tokens sitting in the contract

                int256 diff = amount + int256(contractBalance);

                if (diff > 0) {
                    // we still made some profit

                    /// @dev send the profit to BentoBox and reinvest the rest
                    IERC20(strategyToken).safeTransfer(bentoBox, uint256(diff));
                    _skim(uint256(-amount));
                } else {
                    // we made a loss but we have some tokens we can reinvest

                    _skim(contractBalance);
                }

                return diff;
            } else {
                // we made a loss

                return amount;
            }
        }

        return int256(0);
    }

    /// @inheritdoc IStrategy
    function withdraw(uint256 amount) external override isActive onlyBentoBox returns (uint256 actualAmount) {
        _withdraw(amount);
        /// @dev Make sure we send and report the exact same amount of tokens by using balanceOf.
        actualAmount = IERC20(strategyToken).balanceOf(address(this));
        IERC20(strategyToken).safeTransfer(bentoBox, actualAmount);
    }

    /// @inheritdoc IStrategy
    /// @dev do not use isActive modifier here; allow bentobox to call strategy.exit() multiple times
    function exit(uint256 balance) external override onlyBentoBox returns (int256 amountAdded) {
        _exit();
        /// @dev Check balance of token on the contract.
        uint256 actualBalance = IERC20(strategyToken).balanceOf(address(this));
        /// @dev Calculate tokens added (or lost).
        amountAdded = int256(actualBalance) - int256(balance);
        /// @dev Transfer all tokens to bentoBox.
        IERC20(strategyToken).safeTransfer(bentoBox, actualBalance);
        /// @dev Flag as exited, allowing the owner to manually deal with any amounts available later.
        exited = true;
    }

    /** @dev After exited, the owner can perform ANY call. This is to rescue any funds that didn't
        get released during exit or got earned afterwards due to vesting or airdrops, etc. */
    function afterExit(
        address to,
        uint256 value,
        bytes memory data
    ) public onlyOwner returns (bool success) {
        require(exited, "BentoBox Strategy: not exited");
        (success, ) = to.call{value: value}(data);
    }

    /// @notice Swap some tokens in the contract for the underlying and deposits them to address(this)
    function swapExactTokensForUnderlying(uint256 amountOutMin, address inputToken) public onlyExecutor returns (uint256 amountOut) {
        require(factory != address(0), "BentoBox Strategy: cannot swap");
        require(inputToken != strategyToken, "BentoBox Strategy: invalid swap");

        ///@dev Construct a path array consisting of the input (reward token),
        /// underlying token and a potential bridge token
        bool useBridge = bridgeToken != address(0);

        address[] memory path = new address[](useBridge ? 3 : 2);

        path[0] = inputToken;

        if (useBridge) {
            path[1] = bridgeToken;
        }

        path[path.length - 1] = strategyToken;

        uint256 amountIn = IERC20(path[0]).balanceOf(address(this));

        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);

        amountOut = amounts[amounts.length - 1];

        require(amountOut >= amountOutMin, "BentoBox Strategy: insufficient output");

        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amounts[0]);

        _swap(amounts, path, address(this));

        emit LogConvert(msg.sender, inputToken, strategyToken, amountIn, amountOut);
    }

    /// @dev requires the initial amount to have already been sent to the first pair
    function _swap(
        uint256[] memory amounts,
        address[] memory path,
        address _to
    ) internal {
        for (uint256 i; i < path.length - 1; i++) {
            (address input, address output) = (path[i], path[i + 1]);
            address token0 = input < output ? input : output;
            uint256 amountOut = amounts[i + 1];
            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2], pairCodeHash) : _to;
            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output, pairCodeHash)).swap(amount0Out, amount1Out, to, new bytes(0));
        }
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

interface IStrategy {
    /// @notice Send the assets to the Strategy and call skim to invest them.
    /// @param amount The amount of tokens to invest.
    function skim(uint256 amount) external;

    /// @notice Harvest any profits made converted to the asset and pass them to the caller.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);

    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.
    /// @dev The `actualAmount` should be very close to the amount.
    /// The difference should NOT be used to report a loss. That's what harvest is for.
    /// @param amount The requested amount the caller wants to withdraw.
    /// @return actualAmount The real amount that is withdrawn.
    function withdraw(uint256 amount) external returns (uint256 actualAmount);

    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.
    /// @param balance The amount of tokens the caller thinks it has invested.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    function exit(uint256 balance) external returns (int256 amountAdded);
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

interface IUniswapV2Pair {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
}

// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.7;

/// @notice Minimal interface for BentoBox token vault interactions - `token` is aliased as `address` from `IERC20` for code simplicity.
interface IBentoBoxMinimal {

    struct Rebase {
        uint128 elastic;
        uint128 base;
    }

    struct StrategyData {
        uint64 strategyStartDate;
        uint64 targetPercentage;
        uint128 balance; // the balance of the strategy that BentoBox thinks is in there
    }

    function strategyData(address token) external view returns (StrategyData memory);

    /// @notice Balance per ERC-20 token per account in shares.
    function balanceOf(address, address) external view returns (uint256);

    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.
    /// @param token_ The ERC-20 token to deposit.
    /// @param from which account to pull the tokens.
    /// @param to which account to push the tokens.
    /// @param amount Token amount in native representation to deposit.
    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.
    /// @return amountOut The amount deposited.
    /// @return shareOut The deposited amount repesented in shares.
    function deposit(
        address token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external payable returns (uint256 amountOut, uint256 shareOut);

    /// @notice Withdraws an amount of `token` from a user account.
    /// @param token_ The ERC-20 token to withdraw.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.
    /// @param share Like above, but `share` takes precedence over `amount`.
    function withdraw(
        address token_,
        address from,
        address to,
        uint256 amount,
        uint256 share
    ) external returns (uint256 amountOut, uint256 shareOut);

    /// @notice Transfer shares from a user account to another one.
    /// @param token The ERC-20 token to transfer.
    /// @param from which user to pull the tokens.
    /// @param to which user to push the tokens.
    /// @param share The amount of `token` in shares.
    function transfer(
        address token,
        address from,
        address to,
        uint256 share
    ) external;

    /// @dev Helper function to represent an `amount` of `token` in shares.
    /// @param token The ERC-20 token.
    /// @param amount The `token` amount.
    /// @param roundUp If the result `share` should be rounded up.
    /// @return share The token amount represented in shares.
    function toShare(
        address token,
        uint256 amount,
        bool roundUp
    ) external view returns (uint256 share);

    /// @dev Helper function to represent shares back into the `token` amount.
    /// @param token The ERC-20 token.
    /// @param share The amount of shares.
    /// @param roundUp If the result should be rounded up.
    /// @return amount The share amount back into native representation.
    function toAmount(
        address token,
        uint256 share,
        bool roundUp
    ) external view returns (uint256 amount);

    /// @notice Registers this contract so that users can approve it for the BentoBox.
    function registerProtocol() external;

    function totals(address token) external view returns (Rebase memory);

    function harvest(
        address token,
        bool balance,
        uint256 maxChangeAmount
    ) external;
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "../interfaces/IUniswapV2Pair.sol";

/* 
The following library is modified from @sushiswap/core/contracts/uniswapv2/libraries/UniswapV2Library.sol

changes: 
    - remove SafeMathUniswap library and replace all usage of it with basic operations
    - change casting from uint to bytes20 in pair address calculation and shift by 96 bits before casting
 */

library UniswapV2Library {
    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, "UniswapV2Library: IDENTICAL_ADDRESSES");
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), "UniswapV2Library: ZERO_ADDRESS");
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(
        address factory,
        address tokenA,
        address tokenB,
        bytes32 pairCodeHash
    ) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);

        // Since Solidity 0.8.0 explicit conversions from literals larger than type(uint160).max to address are disallowed.
        // https://docs.soliditylang.org/en/develop/080-breaking-changes.html#new-restrictions
        pair = address(
            uint160(
                uint256(
                    keccak256(
                        abi.encodePacked(
                            hex"ff",
                            factory,
                            keccak256(abi.encodePacked(token0, token1)),
                            pairCodeHash // init code hash
                        )
                    )
                )
            )
        );
    }

    // fetches and sorts the reserves for a pair
    function getReserves(
        address factory,
        address tokenA,
        address tokenB,
        bytes32 pairCodeHash
    ) internal view returns (uint256 reserveA, uint256 reserveB) {
        (address token0, ) = sortTokens(tokenA, tokenB);
        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(
        uint256 amountA,
        uint256 reserveA,
        uint256 reserveB
    ) internal pure returns (uint256 amountB) {
        require(amountA > 0, "UniswapV2Library: INSUFFICIENT_AMOUNT");
        require(reserveA > 0 && reserveB > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
        amountB = (amountA * reserveB) / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountOut) {
        require(amountIn > 0, "UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT");
        require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
        uint256 amountInWithFee = amountIn * 997;
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = (reserveIn * 1000) + amountInWithFee;
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountIn) {
        require(amountOut > 0, "UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT");
        require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
        uint256 numerator = reserveIn * amountOut * 1000;
        uint256 denominator = (reserveOut - amountOut) * 997;
        amountIn = (numerator / denominator) + 1;
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(
        address factory,
        uint256 amountIn,
        address[] memory path,
        bytes32 pairCodeHash
    ) internal view returns (uint256[] memory amounts) {
        require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
        amounts = new uint256[](path.length);
        amounts[0] = amountIn;
        for (uint256 i; i < path.length - 1; i++) {
            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(
        address factory,
        uint256 amountOut,
        address[] memory path,
        bytes32 pairCodeHash
    ) internal view returns (uint256[] memory amounts) {
        require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
        amounts = new uint256[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint256 i = path.length - 1; i > 0; i--) {
            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i], pairCodeHash);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../BaseStrategy.sol";
import "../interfaces/ISushiSwap.sol";
import "../interfaces/IMasterChef.sol";
import "../libraries/Babylonian.sol";

interface IxJOE is IERC20 {
    function enter(uint256 _amount) external;
    function leave(uint256 _share) external;
} 

contract XJOEStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);

    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline
    uint256 private constant FEE = 10; // 10% fees on minted LP

    ISushiSwap private immutable router;
    IMasterChef private immutable masterchef;
    uint256 private constant pid = 24;

    IERC20 private constant JOE = IERC20(0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd);

    address public feeCollector;

    /** @param _strategyToken Address of the underlying LP token the strategy invests.
        @param _bentoBox BentoBox address.
        @param _factory SushiSwap factory.
        @param _bridgeToken An intermediary token for swapping any rewards into it before swapping it to _inputPairToken
        @param _strategyExecutor an EOA that will execute the safeHarvest function.
    */
    constructor(
        address _strategyToken,
        address _bentoBox,
        address _factory,
        address _bridgeToken,
        address _strategyExecutor,
        IMasterChef _masterchef,
        ISushiSwap _router,
        bytes32 _pairCodeHash
    ) BaseStrategy(_strategyToken, _bentoBox, _factory, _bridgeToken, _strategyExecutor, _pairCodeHash) {

        masterchef = _masterchef;
        router = _router;
        feeCollector = _msgSender();

        IERC20(_strategyToken).safeApprove(address(_masterchef), type(uint256).max);
        IERC20(JOE).safeApprove(address(_strategyToken), type(uint256).max);
    }

    function _skim(uint256 amount) internal override {
        masterchef.deposit(pid, amount);
    }

    function _harvest(uint256) internal override returns (int256) {
        masterchef.withdraw(pid, 0);

        IxJOE(strategyToken).enter(JOE.balanceOf(address(this)));

        uint256 total = IERC20(strategyToken).balanceOf(address(this));
        uint256 feeAmount = (total * FEE) / 100;

        IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);

        return int256(0);
    }

    function _withdraw(uint256 amount) internal override {
        masterchef.withdraw(pid, amount);
    }

    function _exit() internal override {
        masterchef.emergencyWithdraw(pid);
    }

    function setFeeCollector(address _feeCollector) external onlyOwner {
        feeCollector = _feeCollector;
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;
pragma experimental ABIEncoderV2;

/// @notice Interface for SushiSwap.
interface ISushiSwap {
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function token0() external pure returns (address);
    function token1() external pure returns (address);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        external
        returns (
            uint256 amountA,
            uint256 amountB,
            uint256 liquidity
        );

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}

// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.7;

interface IMasterChef {
    function deposit(uint256 _pid, uint256 _amount) external;
    function withdraw(uint256 _pid, uint256 _amount) external;
    function userInfo(uint256 _pid, address user) external view returns (uint256 amount, uint256 rewardDebt);
    function emergencyWithdraw(uint256 _pid) external;
}

interface ICakeChef is IMasterChef {
    function enterStaking(uint256 _amount) external;
    function leaveStaking(uint256 _amount) external;
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).
library Babylonian {
    // computes square roots using the babylonian method
    // credit for this implementation goes to
    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687
    function sqrt(uint256 x) internal pure returns (uint256) {
        if (x == 0) return 0;
        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);
        // however that code costs significantly more gas
        uint256 xx = x;
        uint256 r = 1;
        if (xx >= 0x100000000000000000000000000000000) {
            xx >>= 128;
            r <<= 64;
        }
        if (xx >= 0x10000000000000000) {
            xx >>= 64;
            r <<= 32;
        }
        if (xx >= 0x100000000) {
            xx >>= 32;
            r <<= 16;
        }
        if (xx >= 0x10000) {
            xx >>= 16;
            r <<= 8;
        }
        if (xx >= 0x100) {
            xx >>= 8;
            r <<= 4;
        }
        if (xx >= 0x10) {
            xx >>= 4;
            r <<= 2;
        }
        if (xx >= 0x8) {
            r <<= 1;
        }
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1;
        r = (r + x / r) >> 1; // Seven iterations should be enough
        uint256 r1 = x / r;
        return (r < r1 ? r : r1);
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../BaseStrategy.sol";
import "../interfaces/ISushiSwap.sol";
import "../interfaces/IMasterChef.sol";
import "../libraries/Babylonian.sol";

interface IOracle {
    /// @notice Get the latest exchange rate.
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return success if no valid (recent) rate is available, return false else true.
    /// @return rate The rate of the requested asset / pair / pool.
    function get(bytes calldata data) external returns (bool success, uint256 rate);

    /// @notice Check the last exchange rate without any state changes.
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return success if no valid (recent) rate is available, return false else true.
    /// @return rate The rate of the requested asset / pair / pool.
    function peek(bytes calldata data) external view returns (bool success, uint256 rate);

    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return rate The rate of the requested asset / pair / pool.
    function peekSpot(bytes calldata data) external view returns (uint256 rate);

    /// @notice Returns a human readable (short) name about this oracle.
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return (string) A human readable symbol name about this oracle.
    function symbol(bytes calldata data) external view returns (string memory);

    /// @notice Returns a human readable name about this oracle.
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return (string) A human readable name about this oracle.
    function name(bytes calldata data) external view returns (string memory);
}

interface ICauldronV2 {
    function totalCollateralShare() external view returns (uint256);

    function userCollateralShare(address _user) external view returns (uint256);
}

interface IMasterChefV3 {
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
    }

    struct PoolInfo {
        address lpToken; // Address of LP token contract.
        uint256 accJoePerShare; // How many allocation points assigned to this pool. JOE to distribute per block.
        uint256 lastRewardTimestamp; // Last block number that JOE distribution occurs.
        uint256 allocPoint; // Accumulated JOE per share, times 1e12. See below.
        address rewarder;
    }

    function poolInfo(uint256 pid) external view returns (PoolInfo memory);

    function totalAllocPoint() external view returns (uint256);

    function joePerSec() external view returns (uint256);

    function pendingTokens(uint256 _pid, address _user)
        external
        view
        returns (
            uint256 pendingJoe,
            address bonusTokenAddress,
            string memory bonusTokenSymbol,
            uint256 pendingBonusToken
        );

    function userInfo(uint256 _pid, address user) external view returns (uint256 amount, uint256 rewardDebt);
}

interface IRewarder {
    function tokenPerSec() external view returns (uint256);
}

contract LPStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);
    uint256 public FEE = 150;
    uint256 public FEEReward = 5;
    uint256 private minWAVAX = 100000000000000;
    uint256 public maxChange = 100;

    ISushiSwap private immutable router;
    IMasterChef private immutable masterchef;
    uint256 private immutable pid;
    ICauldronV2 public cauldronV2;

    address private immutable NORTH = 0xD0755413bfE2e08dB6bE72761cdD56d77d4B60f1;
    address private immutable USDTe = 0xc7198437980c041c805A1EDcbA50c1Ce5db95118;
    address private immutable PTP = 0x22d4002028f537599bE9f666d1c4Fa138522f9c8;
    address private immutable rewardToken;
    address private immutable pairInputToken;
    bool private immutable usePairToken0;

    address private usdtJOEOracle = 0x8C927362AF77a7bbC542645Ff3244618354Fe533;
    address private usdtPTPOracle = 0x1279d70E6DaaEb6ff5924bDF8424953d3f97f1c9;
    address private usdtWAVAXPTPLPOracle = 0x392B8332FB29dddE4f4cA8C5Ee58048a6FD15739;
    address private usdtNORTHOracle = 0x7cffdBFAB3a65BCCb2FB8ef3E4b6eB09ec2554e4;
    address private usdtWAVAXOracle = 0x9AC9CBFA47D13fa2bA21F5aAb4CAD68A44300AC7;

    address public feeCollector;
    address public feeRewardCollector;

    constructor(
        address _strategyToken,
        address _bentoBox,
        address _factory,
        address _bridgeToken,
        address _strategyExecutor,
        IMasterChef _masterchef,
        uint256 _pid,
        ISushiSwap _router,
        address _rewardToken,
        bool _usePairToken0,
        bytes32 _pairCodeHash
    ) BaseStrategy(_strategyToken, _bentoBox, _factory, _bridgeToken, _strategyExecutor, _pairCodeHash) {
        masterchef = _masterchef;
        pid = _pid;
        router = _router;
        rewardToken = _rewardToken;
        feeCollector = _msgSender();

        (address token0, address token1) = _getPairTokens(_strategyToken);
        IERC20(token0).safeApprove(address(_router), type(uint256).max);
        IERC20(token1).safeApprove(address(_router), type(uint256).max);
        IERC20(_strategyToken).safeApprove(address(_masterchef), type(uint256).max);

        usePairToken0 = _usePairToken0;
        pairInputToken = _usePairToken0 ? token0 : token1;
    }

    function _skim(uint256 amount) internal override {
        masterchef.deposit(pid, amount);
    }

    function _harvest(uint256) internal override returns (int256) {
        masterchef.withdraw(pid, 0);
        return int256(0);
    }

    function _withdraw(uint256 amountA) internal override {
        masterchef.withdraw(pid, amountA);
    }

    function _exit() internal override {
        //masterchef.emergencyWithdraw(pid);
        (uint256 amount, ) = masterchef.userInfo(pid, address(this));
        masterchef.withdraw(pid, amount);
        if (IERC20(rewardToken).balanceOf(address(this)) > 0) {
            _swapTokens(rewardToken, pairInputToken);
        }

        if (IERC20(PTP).balanceOf(address(this)) > 0) {
            _swapTokens(PTP, pairInputToken);
        }
        uint256 balanceOfWAVAX = IERC20(pairInputToken).balanceOf(address(this));
        IERC20(pairInputToken).safeTransfer(owner(), balanceOfWAVAX);
    }

    function _getPairTokens(address _pairAddress) private pure returns (address token0, address token1) {
        ISushiSwap sushiPair = ISushiSwap(_pairAddress);
        token0 = sushiPair.token0();
        token1 = sushiPair.token1();
    }

    function _swapTokens(address tokenIn, address tokenOut) internal returns (uint256 amountOut) {
        bool useBridge = bridgeToken != address(0);
        address[] memory path = new address[](useBridge ? 3 : 2);

        path[0] = tokenIn;

        if (useBridge) {
            path[1] = bridgeToken;
        }

        path[path.length - 1] = tokenOut;

        uint256 amountIn = IERC20(path[0]).balanceOf(address(this));

        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);
        amountOut = amounts[amounts.length - 1];

        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amounts[0]);
        _swap(amounts, path, address(this));
    }

    function _swapToNorth(uint256 amountIn) private returns (uint256 amountOut) {
        address[] memory path = new address[](3);
        path[0] = pairInputToken;
        path[1] = USDTe;
        path[2] = NORTH;

        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);
        amountOut = amounts[amounts.length - 1];

        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amounts[0]);
        _swap(amounts, path, address(this));
    }

    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {
        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;
    }

    /// @notice Swap some tokens in the contract for the underlying and deposits them to address(this)
    function swapToLP(uint256 amountOutMin) private onlyExecutor returns (uint256 amountOut) {
        if (IERC20(rewardToken).balanceOf(address(this)) > 0) {
            _swapTokens(rewardToken, pairInputToken);
        }

        if (IERC20(PTP).balanceOf(address(this)) > 0) {
            _swapTokens(PTP, pairInputToken);
        }

        uint256 balanceOfWAVAX = IERC20(pairInputToken).balanceOf(address(this));

        if (balanceOfWAVAX >= minWAVAX) {
            uint256 tokenInAmountFee = (balanceOfWAVAX * FEE) / 1000;

            uint256 amountOutNorth = _swapToNorth(tokenInAmountFee);

            uint256 feeRewardAmount = (amountOutNorth * FEEReward) / FEE;

            IERC20(NORTH).safeTransfer(feeRewardCollector, feeRewardAmount);

            uint256 feeAmount = amountOutNorth - feeRewardAmount;

            IERC20(NORTH).safeTransfer(feeCollector, feeAmount);

            (uint256 reserve0, uint256 reserve1, ) = ISushiSwap(strategyToken).getReserves();

            (address token0, address token1) = _getPairTokens(strategyToken);

            uint256 tokenInAmount = balanceOfWAVAX - tokenInAmountFee;

            uint256 swapAmountIn = _calculateSwapInAmount(usePairToken0 ? reserve0 : reserve1, tokenInAmount);

            address[] memory path = new address[](2);
            if (usePairToken0) {
                path[0] = token0;
                path[1] = token1;
            } else {
                path[0] = token1;
                path[1] = token0;
            }

            uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, swapAmountIn, path, pairCodeHash);
            IERC20(path[0]).safeTransfer(strategyToken, amounts[0]);
            _swap(amounts, path, address(this));

            uint256 amountStrategyLpBefore = IERC20(strategyToken).balanceOf(address(this));

            // Minting liquidity with optimal token balances but is still leaving some
            // dust because of rounding. The dust will be used the next time the function
            // is called.
            router.addLiquidity(
                token0,
                token1,
                IERC20(token0).balanceOf(address(this)),
                IERC20(token1).balanceOf(address(this)),
                1,
                1,
                address(this),
                type(uint256).max
            );

            amountOut = IERC20(strategyToken).balanceOf(address(this)) - amountStrategyLpBefore;
            require(amountOut >= amountOutMin, "INSUFFICIENT_AMOUNT_OUT");

            emit LpMinted(amountOut, feeRewardAmount, feeAmount);
        }
    }

    function setFeeCollector(address _feeCollector) external onlyOwner {
        feeCollector = _feeCollector;
    }

    function setFeeRewardCollector(address _feeRewardCollector) external onlyOwner {
        feeRewardCollector = _feeRewardCollector;
        setStrategyExecutor(_feeRewardCollector, true);
    }

    function setMinWAVAX(uint256 _minWAVAX) external onlyOwner {
        minWAVAX = _minWAVAX;
    }

    function setBentoBox(address _bentoBox) external onlyOwner {
        bentoBox = _bentoBox;
    }

    function setCauldronV2(address _cauldronV2) external onlyOwner {
        cauldronV2 = ICauldronV2(_cauldronV2);
        setStrategyExecutor(_cauldronV2, true);
    }

    function setFEEReward(uint256 _feeReward) external onlyOwner {
        FEEReward = _feeReward;
    }

    function setFEE(uint256 _fee) external onlyOwner {
        FEE = _fee;
    }

    function setMaxChange(uint256 _maxChange) external onlyOwner {
        maxChange = _maxChange;
    }

    function firstHarvest() public onlyExecutor {
        uint256 max = 999999999999999999999999000000000000000000;
        safeHarvest(max, true, max, false);
    }

    function autoHarvest() public onlyExecutor {
        uint256 balanceBentoBox = IERC20(strategyToken).balanceOf(address(bentoBox));
        uint256 balanceStrategy = IERC20(strategyToken).balanceOf(address(this));
        (uint256 amount, ) = masterchef.userInfo(pid, address(this));
        uint256 maxBalance = balanceBentoBox + balanceStrategy + amount;
        uint256 maxChangeAmount = (maxBalance * maxChange) / 100;
        safeHarvest(maxBalance, true, maxChangeAmount, false);
    }

    function harvestAndSwapToLP() public onlyExecutor {
        autoHarvest();

        swapToLP(0);

        autoHarvest();
    }

    function refreshReward() public view returns (uint256 pendingValue, uint256 pendingNorth) {
        uint256 joeToUSD = (1e36 / IOracle(usdtJOEOracle).peekSpot(new bytes(0)));
        uint256 ptpToUSD = (1e36 / IOracle(usdtPTPOracle).peekSpot(new bytes(0)));
        uint256 avaxToUSD = (1e36 / IOracle(usdtWAVAXOracle).peekSpot(new bytes(0)));
        uint256 northToUSD = (1e36 / IOracle(usdtNORTHOracle).peekSpot(new bytes(0)));

        uint256 balanceOfLPStrategy = IERC20(pairInputToken).balanceOf(address(this));
        (uint256 pendingJoe, , , uint256 pendingBonusToken) = IMasterChefV3(address(masterchef)).pendingTokens(pid, address(this));
        pendingValue = ((pendingBonusToken * ptpToUSD) + (pendingJoe * joeToUSD) + (balanceOfLPStrategy * avaxToUSD)) / 1e18;
        pendingNorth = ((pendingValue * 1e18) * FEEReward) / northToUSD / 100;
    }

    function baseApr() private view returns (uint256 joeDay, uint256 rewarderTokenDay) {
        uint256 joeToUSD = (1e36 / IOracle(usdtJOEOracle).peekSpot(new bytes(0)));
        uint256 lpToUSD = (1e36 / IOracle(usdtWAVAXPTPLPOracle).peekSpot(new bytes(0)));
        uint256 ptpToUSD = (1e36 / IOracle(usdtPTPOracle).peekSpot(new bytes(0)));

        uint256 lpSupply = IERC20(IMasterChefV3(address(masterchef)).poolInfo(pid).lpToken).balanceOf(address(masterchef));
        joeDay =
            (((IMasterChefV3(address(masterchef)).joePerSec() *
                IMasterChefV3(address(masterchef)).poolInfo(pid).allocPoint *
                1e18 *
                86400) /
                IMasterChefV3(address(masterchef)).totalAllocPoint() /
                lpSupply) * joeToUSD) /
            lpToUSD;

        address rewarderToken = IMasterChefV3(address(masterchef)).poolInfo(pid).rewarder;
        rewarderTokenDay = (((IRewarder(rewarderToken).tokenPerSec() * 1e18 * 86400) / lpSupply) * ptpToUSD) / lpToUSD;
    }

    function apr() public view returns (uint256 finalApr) {
        (uint256 joeDay, uint256 rewarderTokenDay) = baseApr();
        uint64 percent = IBentoBoxMinimal(bentoBox).strategyData(IMasterChefV3(address(masterchef)).poolInfo(pid).lpToken).targetPercentage;
        finalApr = ((joeDay + rewarderTokenDay) * percent) / 100;
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../BaseStrategy.sol";
import "../interfaces/ISushiSwap.sol";
import "../interfaces/IMasterChef.sol";
import "../libraries/Babylonian.sol";

interface IOracle {
    /// @notice Get the latest exchange rate.
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return success if no valid (recent) rate is available, return false else true.
    /// @return rate The rate of the requested asset / pair / pool.
    function get(bytes calldata data) external returns (bool success, uint256 rate);

    /// @notice Check the last exchange rate without any state changes.
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return success if no valid (recent) rate is available, return false else true.
    /// @return rate The rate of the requested asset / pair / pool.
    function peek(bytes calldata data) external view returns (bool success, uint256 rate);

    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return rate The rate of the requested asset / pair / pool.
    function peekSpot(bytes calldata data) external view returns (uint256 rate);

    /// @notice Returns a human readable (short) name about this oracle.
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return (string) A human readable symbol name about this oracle.
    function symbol(bytes calldata data) external view returns (string memory);

    /// @notice Returns a human readable name about this oracle.
    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.
    /// For example:
    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));
    /// @return (string) A human readable name about this oracle.
    function name(bytes calldata data) external view returns (string memory);
}

interface ICauldronV2 {
    function totalCollateralShare() external view returns (uint256);

    function userCollateralShare(address _user) external view returns (uint256);
}

interface IMasterChefV3 {
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
    }

    struct PoolInfo {
        address lpToken; // Address of LP token contract.
        uint256 accJoePerShare; // How many allocation points assigned to this pool. JOE to distribute per block.
        uint256 lastRewardTimestamp; // Last block number that JOE distribution occurs.
        uint256 allocPoint; // Accumulated JOE per share, times 1e12. See below.
        address rewarder;
    }

    function poolInfo(uint256 pid) external view returns (PoolInfo memory);

    function totalAllocPoint() external view returns (uint256);

    function joePerSec() external view returns (uint256);

    function pendingTokens(uint256 _pid, address _user)
        external
        view
        returns (
            uint256 pendingJoe,
            address bonusTokenAddress,
            string memory bonusTokenSymbol,
            uint256 pendingBonusToken
        );

    function userInfo(uint256 _pid, address user) external view returns (uint256 amount, uint256 rewardDebt);
}

interface IRewarder {
    function tokenPerSec() external view returns (uint256);
}

contract JLPStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);
    uint256 public FEE = 150;
    uint256 public FEEReward = 5;
    uint256 private minWAVAX = 100000000000000;
    uint256 public maxChange = 100;

    ISushiSwap private immutable router;
    IMasterChef private immutable masterchef;
    uint256 private immutable pid;
    ICauldronV2 public cauldronV2;

    address private immutable NORTH = 0xD0755413bfE2e08dB6bE72761cdD56d77d4B60f1;
    address private immutable USDTe = 0xc7198437980c041c805A1EDcbA50c1Ce5db95118;
    address private immutable rewardToken;
    address private immutable pairInputToken = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;
    bool private immutable usePairToken0;

    address private usdtJOEOracle = 0x8C927362AF77a7bbC542645Ff3244618354Fe533;
    address private usdtJOEUSDCLPOracle = 0x114297945bE62115BEA387eF6aB1b7747886BAD7;
    address private usdtNORTHOracle = 0x7cffdBFAB3a65BCCb2FB8ef3E4b6eB09ec2554e4;
    address private usdtWAVAXOracle = 0x9AC9CBFA47D13fa2bA21F5aAb4CAD68A44300AC7;

    address public feeCollector;
    address public feeRewardCollector;

    constructor(
        address _strategyToken,
        address _bentoBox,
        address _factory,
        address _bridgeToken,
        address _strategyExecutor,
        IMasterChef _masterchef,
        uint256 _pid,
        ISushiSwap _router,
        address _rewardToken,
        bool _usePairToken0,
        bytes32 _pairCodeHash
    ) BaseStrategy(_strategyToken, _bentoBox, _factory, _bridgeToken, _strategyExecutor, _pairCodeHash) {
        masterchef = _masterchef;
        pid = _pid;
        router = _router;
        rewardToken = _rewardToken;
        feeCollector = _msgSender();

        (address token0, address token1) = _getPairTokens(_strategyToken);
        IERC20(token0).safeApprove(address(_router), type(uint256).max);
        IERC20(token1).safeApprove(address(_router), type(uint256).max);
        IERC20(_strategyToken).safeApprove(address(_masterchef), type(uint256).max);

        usePairToken0 = _usePairToken0;
        //pairInputToken = _usePairToken0 ? token0 : token1;
        //pairInputToken = WAVAX;
    }

    function _skim(uint256 amount) internal override {
        masterchef.deposit(pid, amount);
    }

    function _harvest(uint256) internal override returns (int256) {
        masterchef.withdraw(pid, 0);
        return int256(0);
    }

    function _withdraw(uint256 amountA) internal override {
        masterchef.withdraw(pid, amountA);
    }

    function _exit() internal override {
        //masterchef.emergencyWithdraw(pid);
        (uint256 amount, ) = masterchef.userInfo(pid, address(this));
        masterchef.withdraw(pid, amount);
        if (IERC20(rewardToken).balanceOf(address(this)) > 0) {
            _swapTokens(rewardToken, pairInputToken);
        }
        uint256 balanceOfWAVAX = IERC20(pairInputToken).balanceOf(address(this));
        IERC20(pairInputToken).safeTransfer(owner(), balanceOfWAVAX);
    }

    function _getPairTokens(address _pairAddress) private pure returns (address token0, address token1) {
        ISushiSwap sushiPair = ISushiSwap(_pairAddress);
        token0 = sushiPair.token0();
        token1 = sushiPair.token1();
    }

    function _swapTokens(address tokenIn, address tokenOut) internal returns (uint256 amountOut) {
        bool useBridge = bridgeToken != address(0);
        address[] memory path = new address[](useBridge ? 3 : 2);

        path[0] = tokenIn;

        if (useBridge) {
            path[1] = bridgeToken;
        }

        path[path.length - 1] = tokenOut;

        uint256 amountIn = IERC20(path[0]).balanceOf(address(this));

        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);
        amountOut = amounts[amounts.length - 1];

        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amounts[0]);
        _swap(amounts, path, address(this));
    }

    function _swapToNorth(uint256 amountIn) private returns (uint256 amountOut) {
        address[] memory path = new address[](3);
        path[0] = pairInputToken;
        path[1] = USDTe;
        path[2] = NORTH;

        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);
        amountOut = amounts[amounts.length - 1];

        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amounts[0]);
        _swap(amounts, path, address(this));
    }

    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {
        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;
    }

    /// @notice Swap some tokens in the contract for the underlying and deposits them to address(this)
    function swapToLP(uint256 amountOutMin) private onlyExecutor returns (uint256 amountOut) {
        if (IERC20(rewardToken).balanceOf(address(this)) > 0) {
            _swapTokens(rewardToken, pairInputToken);
        }

        uint256 balanceOfWAVAX = IERC20(pairInputToken).balanceOf(address(this));

        if (balanceOfWAVAX >= minWAVAX) {
            uint256 tokenInAmountFee = (balanceOfWAVAX * FEE) / 1000;

            uint256 amountOutNorth = _swapToNorth(tokenInAmountFee);

            uint256 feeRewardAmount = (amountOutNorth * FEEReward) / FEE;

            IERC20(NORTH).safeTransfer(feeRewardCollector, feeRewardAmount);

            uint256 feeAmount = amountOutNorth - feeRewardAmount;

            IERC20(NORTH).safeTransfer(feeCollector, feeAmount);

            (uint256 reserve0, uint256 reserve1, ) = ISushiSwap(strategyToken).getReserves();

            (address token0, address token1) = _getPairTokens(strategyToken);

            uint256 tokenInAmount = balanceOfWAVAX - tokenInAmountFee;

            uint256 swapAmountIn = _calculateSwapInAmount(usePairToken0 ? reserve0 : reserve1, tokenInAmount);

            address[] memory path = new address[](2);
            if (usePairToken0) {
                path[0] = token0;
                path[1] = token1;
            } else {
                path[0] = token1;
                path[1] = token0;
            }

            uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, swapAmountIn, path, pairCodeHash);
            IERC20(path[0]).safeTransfer(strategyToken, amounts[0]);
            _swap(amounts, path, address(this));

            uint256 amountStrategyLpBefore = IERC20(strategyToken).balanceOf(address(this));

            // Minting liquidity with optimal token balances but is still leaving some
            // dust because of rounding. The dust will be used the next time the function
            // is called.
            router.addLiquidity(
                token0,
                token1,
                IERC20(token0).balanceOf(address(this)),
                IERC20(token1).balanceOf(address(this)),
                1,
                1,
                address(this),
                type(uint256).max
            );

            amountOut = IERC20(strategyToken).balanceOf(address(this)) - amountStrategyLpBefore;
            require(amountOut >= amountOutMin, "INSUFFICIENT_AMOUNT_OUT");

            emit LpMinted(amountOut, feeRewardAmount, feeAmount);
        }
    }

    function setFeeCollector(address _feeCollector) external onlyOwner {
        feeCollector = _feeCollector;
    }

    function setFeeRewardCollector(address _feeRewardCollector) external onlyOwner {
        feeRewardCollector = _feeRewardCollector;
        setStrategyExecutor(_feeRewardCollector, true);
    }

    function setMinWAVAX(uint256 _minWAVAX) external onlyOwner {
        minWAVAX = _minWAVAX;
    }

    function setBentoBox(address _bentoBox) external onlyOwner {
        bentoBox = _bentoBox;
    }

    function setCauldronV2(address _cauldronV2) external onlyOwner {
        cauldronV2 = ICauldronV2(_cauldronV2);
        setStrategyExecutor(_cauldronV2, true);
    }

    function setFEEReward(uint256 _feeReward) external onlyOwner {
        FEEReward = _feeReward;
    }

    function setFEE(uint256 _fee) external onlyOwner {
        FEE = _fee;
    }

    function setMaxChange(uint256 _maxChange) external onlyOwner {
        maxChange = _maxChange;
    }

    function firstHarvest() public onlyExecutor {
        uint256 max = 999999999999999999999999000000000000000000;
        safeHarvest(max, true, max, false);
    }

    function autoHarvest() public onlyExecutor {
        uint256 balanceBentoBox = IERC20(strategyToken).balanceOf(address(bentoBox));
        uint256 balanceStrategy = IERC20(strategyToken).balanceOf(address(this));
        (uint256 amount, ) = masterchef.userInfo(pid, address(this));
        uint256 maxBalance = balanceBentoBox + balanceStrategy + amount;
        uint256 maxChangeAmount = (maxBalance * maxChange) / 100;
        safeHarvest(maxBalance, true, maxChangeAmount, false);
    }

    function harvestAndSwapToLP() public onlyExecutor {
        autoHarvest();

        swapToLP(0);

        autoHarvest();
    }

    function refreshReward() public view returns (uint256 pendingValue, uint256 pendingNorth) {
        uint256 joeToUSD = (1e36 / IOracle(usdtJOEOracle).peekSpot(new bytes(0)));
        uint256 avaxToUSD = (1e36 / IOracle(usdtWAVAXOracle).peekSpot(new bytes(0)));
        uint256 northToUSD = (1e36 / IOracle(usdtNORTHOracle).peekSpot(new bytes(0)));

        uint256 balanceOfLPStrategy = IERC20(pairInputToken).balanceOf(address(this));
        (uint256 pendingJoe, , , ) = IMasterChefV3(address(masterchef)).pendingTokens(pid, address(this));
        pendingValue = ((pendingJoe * joeToUSD) + (balanceOfLPStrategy * avaxToUSD)) / 1e18;
        pendingNorth = ((pendingValue * 1e18) * FEEReward) / northToUSD / 100;
    }

    function baseApr() public view returns (uint256 joeDay) {
        uint256 joeToUSD = (1e36 / IOracle(usdtJOEOracle).peekSpot(new bytes(0)));
        uint256 lpToUSD = (1e36 / IOracle(usdtJOEUSDCLPOracle).peekSpot(new bytes(0)));

        uint256 lpSupply = IERC20(IMasterChefV3(address(masterchef)).poolInfo(pid).lpToken).balanceOf(address(masterchef));
        joeDay =
            (((IMasterChefV3(address(masterchef)).joePerSec() *
                IMasterChefV3(address(masterchef)).poolInfo(pid).allocPoint *
                1e18 *
                86400) /
                IMasterChefV3(address(masterchef)).totalAllocPoint() /
                lpSupply) * joeToUSD) /
            lpToUSD;
    }

    function apr() public view returns (uint256 finalApr) {
        uint256 joeDay = baseApr();
        uint64 percent = IBentoBoxMinimal(bentoBox).strategyData(IMasterChefV3(address(masterchef)).poolInfo(pid).lpToken).targetPercentage;
        finalApr = (joeDay * percent) / 100;
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../BaseStrategy.sol";
import "../interfaces/ISushiSwap.sol";
import "../interfaces/IMasterChef.sol";
import "../libraries/Babylonian.sol";


contract CakeStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    event LpMinted(uint256 total, uint256 strategyAmount, uint256 feeAmount);

    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline
    uint256 private constant FEE = 10; // 10% fees on minted LP

    ICakeChef private immutable masterchef;

    address public feeCollector;

    /** @param _strategyToken Address of the underlying LP token the strategy invests.
        @param _bentoBox BentoBox address.
        @param _factory SushiSwap factory.
        @param _bridgeToken An intermediary token for swapping any rewards into it before swapping it to _inputPairToken
        @param _strategyExecutor an EOA that will execute the safeHarvest function.
    */
    constructor(
        address _strategyToken,
        address _bentoBox,
        address _factory,
        address _bridgeToken,
        address _strategyExecutor,
        ICakeChef _masterchef,
        bytes32 _pairCodeHash
    ) BaseStrategy(_strategyToken, _bentoBox, _factory, _bridgeToken, _strategyExecutor, _pairCodeHash) {

        masterchef = _masterchef;
        feeCollector = _msgSender();

        IERC20(_strategyToken).safeApprove(address(_masterchef), type(uint256).max);
    }

    function _skim(uint256 amount) internal override {
        masterchef.enterStaking(amount);
    }

    function _harvest(uint256) internal override returns (int256) {
        masterchef.leaveStaking(0);

        uint256 total = IERC20(strategyToken).balanceOf(address(this));
        uint256 feeAmount = (total * FEE) / 100;

        IERC20(strategyToken).safeTransfer(feeCollector, feeAmount);

        return int256(0);
    }

    function _withdraw(uint256 amount) internal override {
        masterchef.leaveStaking(amount);
    }

    function _exit() internal override {
        masterchef.emergencyWithdraw(0);
    }

    function setFeeCollector(address _feeCollector) external onlyOwner {
        feeCollector = _feeCollector;
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;
import "../interfaces/IStrategy.sol";
import "../interfaces/IUniswapV2Pair.sol";
import "../interfaces/IBentoBoxMinimal.sol";
import "../libraries/UniswapV2Library.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

interface IAnchorRouter {
    function depositStable(uint256 _amount) external;
    function redeemStable(uint256 _amount) external;
}

interface IExchangeRateFeeder {
    function exchangeRateOf(
        address _token,
        bool _simulate
    ) external view returns (uint256);
}

abstract contract BaseStrategy is IStrategy, Ownable {

    using SafeERC20 for IERC20;

    address public immutable strategyToken;
    address public immutable bentoBox;
    address public immutable factory;
    address public immutable bridgeToken;

    bool public exited; /// @dev After bentobox 'exits' the strategy harvest, skim and withdraw functions can no loner be called
    uint256 public maxBentoBoxBalance; /// @dev Slippage protection when calling harvest
    mapping(address => bool) public strategyExecutors; /// @dev EOAs that can execute safeHarvest

    event LogConvert(address indexed server, address indexed token0, address indexed token1, uint256 amount0, uint256 amount1);
    event LogSetStrategyExecutor(address indexed executor, bool allowed);

    /** @param _strategyToken Address of the underlying token the strategy invests.
        @param _bentoBox BentoBox address.
        @param _factory SushiSwap factory.
        @param _bridgeToken An intermedieary token for swapping any rewards into the underlying token.
        @param _strategyExecutor an EOA that will execute the safeHarvest function.
        @dev factory and bridgeToken can be address(0) if we don't expect rewards we would need to swap
    */
    constructor(
        address _strategyToken,
        address _bentoBox,
        address _factory,
        address _bridgeToken,
        address _strategyExecutor
    ) {
        
        strategyToken = _strategyToken;
        bentoBox = _bentoBox;
        factory = _factory;
        bridgeToken = _bridgeToken;
        
        if (_strategyExecutor != address(0)) {
            strategyExecutors[_strategyExecutor] = true;
            emit LogSetStrategyExecutor(_strategyExecutor, true);
        }
    }

    //** Strategy implementation: override the following functions: */

    /// @notice Invests the underlying asset.
    /// @param amount The amount of tokens to invest.
    /// @dev Assume the contract's balance is greater than the amount
    function _skim(uint256 amount) internal virtual;

    /// @notice Harvest any profits made and transfer them to address(this) or report a loss
    /// @param balance The amount of tokens that have been invested.
    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.
    /// @dev amountAdded can be left at 0 when reporting profits (gas savings).
    /// amountAdded should not reflect any rewards or tokens the strategy received.
    /// Calcualte the amount added based on what the current deposit is worth.
    /// (The Base Strategy harvest function accounts for rewards).
    function _harvest(uint256 balance) internal virtual returns (int256 amountAdded);

    /// @dev Withdraw the requested amount of the underlying tokens to address(this).
    /// @param amount The requested amount we want to withdraw.
    function _withdraw(uint256 amount) internal virtual;

    /// @notice Withdraw the maximum available amount of the invested assets to address(this).
    /// @dev This shouldn't revert (use try catch).
    function _exit() internal virtual;

    /// @notice Claim any rewards reward tokens and optionally sell them for the underlying token.
    /// @dev Doesn't need to be implemented if we don't expect any rewards.
    function _harvestRewards() internal virtual {}

    //** End strategy implementation */

    modifier isActive() {
        require(!exited, "BentoBox Strategy: exited");
        _;
    }

    modifier onlyBentoBox() {
        require(msg.sender == bentoBox, "BentoBox Strategy: only BentoBox");
        _;
    }

    modifier onlyExecutor() {
        require(strategyExecutors[msg.sender], "BentoBox Strategy: only Executors");
        _;
    }

    function setStrategyExecutor(address executor, bool value) external onlyOwner {
        strategyExecutors[executor] = value;
        emit LogSetStrategyExecutor(executor, value);
    }

    /// @inheritdoc IStrategy
    function skim(uint256 amount) external override {
        _skim(amount);
    }

    /// @notice Harvest profits while preventing a sandwich attack exploit.
    /// @param maxBalance The maximum balance of the underlying token that is allowed to be in BentoBox.
    /// @param rebalance Whether BentoBox should rebalance the strategy assets to acheive it's target allocation.
    /// @param maxChangeAmount When rebalancing - the maximum amount that will be deposited to or withdrawn from a strategy to BentoBox.
    /// @param harvestRewards If we want to claim any accrued reward tokens
    /// @dev maxBalance can be set to 0 to keep the previous value.
    /// @dev maxChangeAmount can be set to 0 to allow for full rebalancing.
    function safeHarvest(
        uint256 maxBalance,
        bool rebalance,
        uint256 maxChangeAmount,
        bool harvestRewards
    ) external onlyExecutor {
        if (harvestRewards) {
            _harvestRewards();
        }

        if (maxBalance > 0) {
            maxBentoBoxBalance = maxBalance;
        }

        IBentoBoxMinimal(bentoBox).harvest(strategyToken, rebalance, maxChangeAmount);
    }

    /// @inheritdoc IStrategy
    function withdraw(uint256 amount) external override isActive onlyBentoBox returns (uint256 actualAmount) {
        _withdraw(amount);
        /// @dev Make sure we send and report the exact same amount of tokens by using balanceOf.
        actualAmount = IERC20(strategyToken).balanceOf(address(this));
        IERC20(strategyToken).safeTransfer(bentoBox, actualAmount);
    }

    /// @inheritdoc IStrategy
    /// @dev do not use isActive modifier here; allow bentobox to call strategy.exit() multiple times
    function exit(uint256 balance) external override onlyBentoBox returns (int256 amountAdded) {
        _exit();
        /// @dev Check balance of token on the contract.
        uint256 actualBalance = IERC20(strategyToken).balanceOf(address(this));
        /// @dev Calculate tokens added (or lost).
        amountAdded = int256(actualBalance) - int256(balance);
        /// @dev Transfer all tokens to bentoBox.
        IERC20(strategyToken).safeTransfer(bentoBox, actualBalance);
        /// @dev Flag as exited, allowing the owner to manually deal with any amounts available later.
        exited = true;
    }

    /** @dev After exited, the owner can perform ANY call. This is to rescue any funds that didn't
        get released during exit or got earned afterwards due to vesting or airdrops, etc. */
    function afterExit(
        address to,
        uint256 value,
        bytes memory data
    ) public onlyOwner returns (bool success) {
        require(exited, "BentoBox Strategy: not exited");
        (success, ) = to.call{value: value}(data);
    }

}


contract USTStrategy is BaseStrategy {    
    using SafeERC20 for IERC20;

    IAnchorRouter public constant router = IAnchorRouter(0xcEF9E167d3f8806771e9bac1d4a0d568c39a9388);
    IExchangeRateFeeder public feeder = IExchangeRateFeeder(0xB12B8247bD1749CC271c55Bb93f6BD2B485C94A7);
    IERC20 public constant UST = IERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);
    IERC20 public constant aUST = IERC20(0xa8De3e3c934e2A1BB08B010104CcaBBD4D6293ab);
    address private constant degenBox = 0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce;

    constructor(
        address strategyExecutor
    ) BaseStrategy(address(UST), degenBox, address(0), address(0), strategyExecutor) {
        UST.approve(address(router), type(uint256).max);
        aUST.approve(address(router), type(uint256).max);
    }
    
    function _skim(uint256 amount) internal override {
        router.depositStable(amount);
    }

    /** @inheritdoc IStrategy
    @dev Only BentoBox can call harvest on this strategy.
    @dev Ensures that (1) the caller was this contract (called through the safeHarvest function)
        and (2) that we are not being frontrun by a large BentoBox deposit when harvesting profits. */
    function harvest(uint256 balance, address sender) external override isActive onlyBentoBox returns (int256) {
        /** @dev Don't revert if conditions aren't met in order to allow
            BentoBox to continiue execution as it might need to do a rebalance. */

        if (
            sender == address(this) &&
            IBentoBoxMinimal(bentoBox).totals(strategyToken).elastic <= maxBentoBoxBalance &&
            balance > 0
        ) {
            
            int256 amount = _harvest(balance);

            /** @dev Since harvesting of rewards is accounted for seperately we might also have
            some underlying tokens in the contract that the _harvest call doesn't report. 
            E.g. reward tokens that have been sold into the underlying tokens which are now sitting in the contract.
            Meaning the amount returned by the internal _harvest function isn't necessary the final profit/loss amount */

            uint256 contractBalance = IERC20(strategyToken).balanceOf(address(this));

            if (amount >= 0) { // _harvest reported a profit

                if (contractBalance >= uint256(amount)) {
                    IERC20(strategyToken).safeTransfer(bentoBox, uint256(amount));
                    return(amount);
                } else {
                    IERC20(strategyToken).safeTransfer(bentoBox, contractBalance);
                    return int256(contractBalance);
                }

            } else { // we made a loss

                return amount;

            }

        }

        return int256(0);
    }

    function _harvest(uint256 balance) internal view override returns (int256) {
        uint256 exchangeRate = feeder.exchangeRateOf(address(UST), true);
        uint256 keep = toAUST(balance, exchangeRate);
        uint256 total = aUST.balanceOf(address(this)) + toAUST(UST.balanceOf(address(this)), exchangeRate);
        return int256(toUST(total, exchangeRate)) - int256(toUST(keep, exchangeRate));
    }

    function _withdraw(uint256 amount) internal override {
    }

    function redeemEarnings() external onlyExecutor {
        uint256 balance = IBentoBoxMinimal(bentoBox).strategyData(address(UST)).balance;
        uint256 exchangeRate = feeder.exchangeRateOf(address(UST), true);
        uint256 keep = toAUST(balance, exchangeRate);
        uint256 total = aUST.balanceOf(address(this)) + toAUST(UST.balanceOf(address(this)), exchangeRate);
        if (total > keep) router.redeemStable(total - keep);
    }

    function safeDeposit(uint256 amount) external onlyExecutor {
        _skim(amount);
    }

    function safeWithdraw(uint256 amount) external onlyExecutor {
        uint256 exchangeRate = feeder.exchangeRateOf(address(UST), true);
        uint256 requested = toAUST(amount, exchangeRate);
        router.redeemStable(requested);
    }

    function updateExchangeRateFeeder(IExchangeRateFeeder feeder_) external onlyOwner {
        feeder = feeder_;
    }

    function _exit() internal override {
        try router.redeemStable(aUST.balanceOf(address(this))) {} catch {}
    }

    function toUST(uint256 amount, uint256 exchangeRate) public pure returns (uint256) {
        return amount * exchangeRate / 1e18;
    }

    function toAUST(uint256 amount, uint256 exchangeRate) public pure returns (uint256) {
        return amount * 1e18 / exchangeRate;
    }
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./IERC20.sol";
import "./extensions/IERC20Metadata.sol";
import "../../utils/Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);

        uint256 currentAllowance = _allowances[sender][_msgSender()];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }

        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        uint256 currentAllowance = _allowances[_msgSender()][spender];
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `sender` to `recipient`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[sender] = senderBalance - amount;
        }
        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        _afterTokenTransfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.7;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

abstract contract USTMock is ERC20 {
    constructor() ERC20("","") {
        _mint(msg.sender, 1e20);
    }

    function owner() virtual external view returns (address);
    function burn(uint256 amount, bytes32 to) virtual external;
    function mint(address account, uint256 amount) virtual external;
}

// SPDX-License-Identifier: GPL-v3

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

pragma solidity 0.8.7;

interface ILPStrategy {
    function exited() external view returns (bool);

    function harvestAndSwapToLP() external;

    function refreshReward() external view returns (uint256 pendingValue, uint256 pendingNorth);
}

interface CauldronV2 {
    function bentoBox() external view returns (address);

    function collateral() external view returns (address);

    function updateExchangeRate() external returns (bool updated, uint256 rate);
}

interface IBentoBoxV1 {
    function strategy(address token) external view returns (address strategy);

    function balanceOf(address token, address user) external view returns (uint256 share);
}

contract RefreshBtn is Ownable {
    using SafeERC20 for IERC20;

    uint256 public min = 100 * 1e18;

    IBentoBoxV1 public immutable bentoBox;
    IBentoBoxV1 public immutable degenBox;
    address public north = 0xD0755413bfE2e08dB6bE72761cdD56d77d4B60f1;
    address public pole = 0x65069e550C5526c029DC9135eDD02F6683859Ac1;
    CauldronV2[] public bentoBoxCauldronsV2;
    CauldronV2[] public degenBoxCauldronsV2;
    bool public isHarvest = true;
    bool public isUpdate = true;

    constructor(
        IBentoBoxV1 bentoBox_,
        IBentoBoxV1 degenBox_,
        CauldronV2[] memory bentoBoxCauldronsV2_,
        CauldronV2[] memory degenBoxCauldronsV2_
    ) {
        bentoBox = bentoBox_;
        degenBox = degenBox_;
        bentoBoxCauldronsV2 = bentoBoxCauldronsV2_;
        degenBoxCauldronsV2 = degenBoxCauldronsV2_;
    }

    function addCauldron(CauldronV2 _Cauldron) external onlyOwner {
        _addCauldron(_Cauldron);
    }

    function addCauldrons(CauldronV2[] memory _Cauldrons) external onlyOwner {
        for (uint256 i = 0; i < _Cauldrons.length; i++) {
            _addCauldron(_Cauldrons[i]);
        }
    }

    function _addCauldron(CauldronV2 _Cauldron) internal onlyOwner {
        require(address(_Cauldron) != address(0), "invalid cauldron");

        if (_Cauldron.bentoBox() == address(bentoBox)) {
            for (uint256 i = 0; i < bentoBoxCauldronsV2.length; i++) {
                require(bentoBoxCauldronsV2[i] != _Cauldron, "already added");
            }
            bentoBoxCauldronsV2.push(_Cauldron);
        } else if (_Cauldron.bentoBox() == address(degenBox)) {
            for (uint256 i = 0; i < degenBoxCauldronsV2.length; i++) {
                require(degenBoxCauldronsV2[i] != _Cauldron, "already added");
            }
            degenBoxCauldronsV2.push(_Cauldron);
        }
    }

    function pending() public view returns (uint256, uint256) {
        uint256 pendingUsd;
        uint256 pendingNORTHAmt;
        for (uint256 i = 0; i < degenBoxCauldronsV2.length; i++) {
            address collateral = degenBoxCauldronsV2[i].collateral();
            address strategyLP = degenBox.strategy(collateral);
            if (!ILPStrategy(strategyLP).exited()) {
                (uint256 pendingValue, uint256 pendingNorth) = ILPStrategy(strategyLP).refreshReward();
                pendingNORTHAmt += pendingNorth;
                pendingUsd += pendingValue;
            }
        }
        return (pendingNORTHAmt, pendingUsd);
    }

    function _updateExchangeRate() internal {
        for (uint256 i = 0; i < bentoBoxCauldronsV2.length; i++) {
            uint256 balanceOfPole = bentoBox.balanceOf(address(pole), address(bentoBoxCauldronsV2[i]));
            if (balanceOfPole >= min) {
                bentoBoxCauldronsV2[i].updateExchangeRate();
            }
        }

        for (uint256 i = 0; i < degenBoxCauldronsV2.length; i++) {
            uint256 balanceOfPole = degenBox.balanceOf(address(pole), address(degenBoxCauldronsV2[i]));
            if (balanceOfPole >= min) {
                degenBoxCauldronsV2[i].updateExchangeRate();
            }
        }
    }

    function _harvest() internal {
        for (uint256 i = 0; i < degenBoxCauldronsV2.length; i++) {
            address collateral = degenBoxCauldronsV2[i].collateral();
            address strategyLP = degenBox.strategy(collateral);
            if (!ILPStrategy(strategyLP).exited()) {
                ILPStrategy(strategyLP).harvestAndSwapToLP();
            }
        }
    }

    function refresh(bool _type) public returns (uint256) {
        if (isHarvest) {
            _harvest();
        }
        if (isUpdate) {
            _updateExchangeRate();
        }
        uint256 reward = IERC20(north).balanceOf(address(this));
        require(reward > 0 || _type, "Refeshbtn: Insufficient Reward");
        IERC20(north).safeTransfer(msg.sender, reward);
        return reward;
    }

    function emergencyWithdrawal(address _erc20, uint256 _amt) public onlyOwner returns (bool) {
        IERC20(_erc20).safeTransfer(msg.sender, _amt);
        return true;
    }
}

// SPDX-License-Identifier: GPL-v3

import "@openzeppelin/contracts/access/Ownable.sol";
import "../interfaces/IBentoBoxMinimal.sol";

pragma solidity 0.8.7;

interface ISafeStrategy {
	function safeHarvest(
		uint256 maxBalance,
		bool rebalance,
		uint256 maxChangeAmount,
		bool harvestRewards
	) external;

    function swapExactTokensForUnderlying(uint256 amountOutMin, address inputToken) external;
    function strategyToken() external view returns(address);
}

// 🚜🚜🚜
contract CombineHarvester is Ownable {

    IBentoBoxMinimal immutable public bentoBox;

    constructor(address _bentoBox) {
        bentoBox = IBentoBoxMinimal(_bentoBox);
    }

    function executeSafeHarvests(
        ISafeStrategy[] memory strategies,
        bool[] memory manual,
        uint256[] memory maxBalances,
        bool[] memory rebalances,
        uint256[] memory maxChangeAmounts, // can be set to 0 to allow for full withdrawals / deposits
        bool[] memory harvestRewards,
        uint256[] memory minOutAmounts
    ) external onlyOwner {
        for (uint256 i = 0; i < strategies.length; i++) {
            
            // BentoBox frontrunning deposit protection - likely won't be needed for Polygon since we will be frequently executing.
            uint256 maxBalance = manual[i] ? maxBalances[i] : 0;
            
            // If BentoBox has to rebalance strategy assets to the target percentage.
            bool rebalance = manual[i] ? rebalances[i] : _rebalanceNecessairy(strategies[i]);
            
            strategies[i].safeHarvest(maxBalance, rebalance, maxChangeAmounts[i], harvestRewards[i]);
            
            if (minOutAmounts[i] > 0) {
                // we only expect wmatic rewards for the current aave strategies
                address inputToken = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;
                strategies[i].swapExactTokensForUnderlying(minOutAmounts[i], inputToken);
            }
        }
    }

    // returns true if strategy balance differs more than -+3% from the strategy target balance
    function _rebalanceNecessairy(ISafeStrategy strategy) public view returns (bool) {
        
        address token = strategy.strategyToken();
        
        IBentoBoxMinimal.StrategyData memory data = bentoBox.strategyData(token);
        
        uint256 targetStrategyBalance = bentoBox.totals(token).elastic * data.targetPercentage / 100; // targetPercentage ∈ [0, 100]

        if (data.balance == 0) return targetStrategyBalance != 0;
        
        uint256 ratio = targetStrategyBalance * 100 / data.balance;
        
        return ratio >= 103 || ratio <= 97;
    }
}

// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.7;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract ERC20Mock is ERC20 {
    constructor() ERC20("","") {
        _mint(msg.sender, 1e20);
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "../BaseStrategy.sol";

interface ISushiBar is IERC20 {
    function enter(uint256 _amount) external;

    function leave(uint256 _share) external;
}

contract SushiStrategy is BaseStrategy {
    ISushiBar public immutable sushiBar;

    constructor(
        address _sushiBar,
        address strategyToken,
        address bentoBox,
        address strategyExecutor,
        bytes32 pairHashCode
    ) BaseStrategy(strategyToken, bentoBox, strategyExecutor, address(0), address(0), pairHashCode) {
        IERC20(strategyToken).approve(_sushiBar, type(uint256).max);
        sushiBar = ISushiBar(_sushiBar);
    }

    function _skim(uint256 amount) internal override {
        sushiBar.enter(amount);
    }

    function _harvest(uint256 balance) internal override returns (int256) {
        uint256 keep = toShare(balance);
        uint256 total = sushiBar.balanceOf(address(this));
        if (total > keep) sushiBar.leave(total - keep);
        // xSUSHI can't report a loss so no need to check for keep < total case
        // we can return 0 when reporting profits (BaseContract checks balanceOf)
        return int256(0);
    }

    function _withdraw(uint256 amount) internal override {
        uint256 requested = toShare(amount);
        uint256 actual = sushiBar.balanceOf(address(this));
        sushiBar.leave(requested > actual ? actual : requested);
    }

    function _exit() internal override {
        sushiBar.leave(sushiBar.balanceOf(address(this)));
    }

    function toShare(uint256 amount) internal view returns (uint256) {
        uint256 totalShares = sushiBar.totalSupply();
        uint256 totalSushi = IERC20(strategyToken).balanceOf(address(sushiBar));
        return amount * totalShares / totalSushi;
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "../BaseStrategy.sol";

library DataTypes {
    struct ReserveData {
        ReserveConfigurationMap configuration;
        uint128 liquidityIndex;
        uint128 variableBorrowIndex;
        uint128 currentLiquidityRate;
        uint128 currentVariableBorrowRate;
        uint128 currentStableBorrowRate;
        uint40 lastUpdateTimestamp;
        address aTokenAddress;
        address stableDebtTokenAddress;
        address variableDebtTokenAddress;
        address interestRateStrategyAddress;
        uint8 id;
    }
    struct ReserveConfigurationMap {
        uint256 data;
    }
}

interface ILendingPool {
    function deposit(
        address asset,
        uint256 amount,
        address onBehalfOf,
        uint16 referralCode
    ) external;

    function withdraw(
        address asset,
        uint256 amount,
        address to
    ) external returns (uint256);

    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);
}

interface IAaveIncentivesController {
    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);

    function claimRewards(
        address[] calldata assets,
        uint256 amount,
        address to
    ) external returns (uint256);
}

contract AaveStrategy is BaseStrategy {
    ILendingPool public immutable aaveLendingPool;
    IAaveIncentivesController public immutable incentiveController;
    IERC20 public immutable aToken;

    constructor(
        ILendingPool _aaveLendingPool,
        IAaveIncentivesController _incentiveController,
        address strategyToken,
        address bentoBox,
        address strategyExecutor,
        address factory,
        address bridgeToken,
        bytes32 pairHashCode
    ) BaseStrategy(strategyToken, bentoBox, factory, bridgeToken, strategyExecutor, pairHashCode)  {
        aaveLendingPool = _aaveLendingPool;
        incentiveController = _incentiveController;
        aToken = IERC20(_aaveLendingPool.getReserveData(strategyToken).aTokenAddress);
        IERC20(strategyToken).approve(address(_aaveLendingPool), type(uint256).max);
    }

    function _skim(uint256 amount) internal override {
        aaveLendingPool.deposit(address(strategyToken), amount, address(this), 0);
    }

    function _harvest(uint256 balance) internal override returns (int256 amountAdded) {
        uint256 currentBalance = aToken.balanceOf(address(this));
        amountAdded = int256(currentBalance) - int256(balance);
        if (amountAdded > 0) aaveLendingPool.withdraw(address(strategyToken), uint256(amountAdded), address(this));
    }

    function _withdraw(uint256 amount) internal override {
        aaveLendingPool.withdraw(address(strategyToken), amount, address(this));
    }

    function _exit() internal override {
        uint256 tokenBalance = aToken.balanceOf(address(this));
        uint256 available = IERC20(strategyToken).balanceOf(address(aToken));
        if (tokenBalance <= available) {
            /// @dev If there are more tokens available than our full position, take all based on aToken balance (continue if unsuccessful).
            try aaveLendingPool.withdraw(address(strategyToken), tokenBalance, address(this)) {} catch {}
        } else {
            /// @dev Otherwise redeem all available and take a loss on the missing amount (continue if unsuccessful).
            try aaveLendingPool.withdraw(address(strategyToken), available, address(this)) {} catch {}
        }
    }

    function _harvestRewards() internal virtual override {
        address[] memory rewardTokens = new address[](1);
        rewardTokens[0] = address(aToken);
        uint256 reward = incentiveController.getRewardsBalance(rewardTokens, address(this));
        incentiveController.claimRewards(rewardTokens, reward, address(this));
    }
}

// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity 0.8.7;

import "./AaveStrategy.sol";

interface IStkAave {
    function stakersCooldowns(address staker) external view returns(uint256);
    function cooldown() external;
    function COOLDOWN_SECONDS() external returns(uint256);
    function UNSTAKE_WINDOW() external returns(uint256);
    function redeem(address to, uint256 amount) external;
    function claimRewards(address to, uint256 amount) external;
}

contract AaveStrategyMainnet is AaveStrategy {

    IStkAave public immutable stkAave;
    uint256 public immutable COOLDOWN_SECONDS; // 10 days
    uint256 public immutable UNSTAKE_WINDOW; // 2 days

    constructor(
        IStkAave _stkAave,
        ILendingPool aaveLendingPool,
        IAaveIncentivesController incentiveController,
        address strategyToken,
        address bentoBox,
        address strategyExecutor,
        address factory,
        address bridgeToken,
        bytes32 pairHashCode
    ) AaveStrategy(aaveLendingPool,incentiveController,strategyToken,bentoBox,strategyExecutor,factory,bridgeToken,pairHashCode) {
        stkAave = _stkAave;
        COOLDOWN_SECONDS = _stkAave.COOLDOWN_SECONDS();
        UNSTAKE_WINDOW = _stkAave.UNSTAKE_WINDOW();
    }

    function _harvestRewards() internal override {
        if (address(stkAave) == address(0)) return;
        
        address[] memory rewardTokens = new address[](1);
        rewardTokens[0] = address(aToken);

        // We can pass type(uint256).max to receive all of the rewards
        // We receive stkAAVE tokens
        incentiveController.claimRewards(rewardTokens, type(uint256).max, address(this));
        
        // Now we try to unstake the stkAAVE tokens
        uint256 cooldown = stkAave.stakersCooldowns(address(this));

        if (cooldown == 0) {
            
            // We initiate unstaking for the stkAAVE tokens
            stkAave.cooldown();

        } else if (cooldown + COOLDOWN_SECONDS < block.timestamp) {

            if (block.timestamp < cooldown + COOLDOWN_SECONDS + UNSTAKE_WINDOW) {

                // We claim any AAVE rewards we have from staking AAVE
                stkAave.claimRewards(address(this), type(uint256).max);
                // We unstake stkAAVE and receive AAVE tokens
                stkAave.redeem(address(this), type(uint256).max);

            } else {
            
                // We missed the unstake window - we have to reset the cooldown timestamp
                stkAave.cooldown();

            }
        }
    }
}