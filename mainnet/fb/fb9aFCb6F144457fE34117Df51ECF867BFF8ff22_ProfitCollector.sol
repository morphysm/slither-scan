// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

import {Controllable} from "./lib/Controllable.sol";

/// @title Beluga Profit Collector
/// @author Chainvisions
/// @notice Collects data on Beluga's protocol profits.

contract ProfitCollector is Controllable {
    struct ProfitData {
        uint256 epoch;
        uint256 profits;
    }

    /// @notice Data on profits from strategy.
    mapping(address => ProfitData) public profitData;

    constructor(address _store) Controllable(_store) {}

    /// @notice Adds profit data for the strategy.
    /// @param _strategy Address of the strategy to add profit data for.
    /// @param _profit Protocol profits from the strategy.
    function addProfits(address _strategy, uint256 _profit) external onlyController {
        ProfitData storage data = profitData[_strategy];
        if((data.epoch + 30 days) < block.timestamp) {
            data.epoch = block.timestamp;
            data.profits = 0;
        }
        data.profits = (data.profits + _profit);
    }

    /// @notice Fetches the current profits of the strategy from `profitData`.
    /// @param _strategy Address of the strategy to collect data from.
    /// @return The protocol profits generated by `_strategy`.
    function viewCurrentProfits(address _strategy) external view returns (uint256) {
        ProfitData storage data = profitData[_strategy];
        return data.profits;
    }
}

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Governable} from "./Governable.sol";

contract Controllable is Governable {

  constructor(address _storage) Governable(_storage) {}

  modifier onlyController() {
    require(store.isController(msg.sender), "Controllable: Not a controller");
    _;
  }

  modifier onlyControllerOrGovernance(){
    require((store.isController(msg.sender) || store.isGovernance(msg.sender)),
      "Controllable: The caller must be controller or governance");
    _;
  }

  function controller() public view returns (address) {
    return store.controller();
  }
}

// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "../Storage.sol";

/**
 * @dev Contract for access control where the governance address specified
 * in the Storage contract can be granted access to specific functions
 * on a contract that inherits this contract.
 */

contract Governable {

  Storage public store;

  constructor(address _store) {
    require(_store != address(0), "Governable: New storage shouldn't be empty");
    store = Storage(_store);
  }

  modifier onlyGovernance() {
    require(store.isGovernance(msg.sender), "Governable: Not governance");
    _;
  }

  function setStorage(address _store) public onlyGovernance {
    require(_store != address(0), "Governable: New storage shouldn't be empty");
    store = Storage(_store);
  }

  function governance() public view returns (address) {
    return store.governance();
  }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Storage {

  address public governance;
  address public controller;

  constructor() {
    governance = msg.sender;
  }

  modifier onlyGovernance() {
    require(isGovernance(msg.sender), "Storage: Not governance");
    _;
  }

  function setGovernance(address _governance) public onlyGovernance {
    require(_governance != address(0), "Storage: New governance shouldn't be empty");
    governance = _governance;
  }

  function setController(address _controller) public onlyGovernance {
    require(_controller != address(0), "Storage: New controller shouldn't be empty");
    controller = _controller;
  }

  function isGovernance(address account) public view returns (bool) {
    return account == governance;
  }

  function isController(address account) public view returns (bool) {
    return account == controller;
  }
}